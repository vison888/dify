# 17-测试层

## 概述

测试层（`tests/`）负责系统的质量保证，包括单元测试、集成测试和端到端测试。该层采用pytest测试框架，提供完整的测试覆盖，确保代码的正确性、可靠性和可维护性。

## 目录结构

```
tests/
├── __init__.py                                    # 测试模块初始化
├── unit_tests/                                     # 单元测试
│   ├── __init__.py                                # 单元测试初始化
│   ├── conftest.py                                # 单元测试配置
│   ├── configs/                                   # 配置测试
│   ├── controllers/                               # 控制器测试
│   ├── core/                                      # 核心功能测试
│   ├── extensions/                                # 扩展测试
│   ├── factories/                                 # 工厂测试
│   ├── libs/                                      # 工具库测试
│   ├── models/                                    # 模型测试
│   ├── oss/                                       # 对象存储测试
│   ├── repositories/                              # 仓储测试
│   ├── services/                                  # 服务测试
│   └── utils/                                     # 工具测试
├── integration_tests/                              # 集成测试
│   ├── __init__.py                                # 集成测试初始化
│   ├── conftest.py                                # 集成测试配置
│   ├── controllers/                               # 控制器集成测试
│   ├── factories/                                 # 工厂集成测试
│   ├── model_runtime/                             # 模型运行时集成测试
│   ├── plugin/                                    # 插件集成测试
│   ├── services/                                  # 服务集成测试
│   ├── tools/                                     # 工具集成测试
│   ├── utils/                                     # 工具集成测试
│   ├── vdb/                                       # 向量数据库集成测试
│   └── workflow/                                  # 工作流集成测试
└── artifact_tests/                                # 制品测试
    └── __init__.py                                # 制品测试初始化
```

## 测试配置详解

### 1. `unit_tests/conftest.py` - 单元测试配置

**职责**: 提供单元测试的基础配置和通用fixture。

**核心配置**:
```python
import os
from unittest.mock import MagicMock, patch
import pytest
from flask import Flask

# 获取项目根目录路径
ABS_PATH = os.path.dirname(os.path.abspath(__file__))
PROJECT_DIR = os.path.abspath(os.path.join(ABS_PATH, os.pardir, os.pardir))

CACHED_APP = Flask(__name__)

# Redis客户端Mock
redis_mock = MagicMock()
redis_mock.get = MagicMock(return_value=None)
redis_mock.setex = MagicMock()
redis_mock.setnx = MagicMock()
redis_mock.delete = MagicMock()
redis_mock.lock = MagicMock()
redis_mock.exists = MagicMock(return_value=False)
redis_mock.set = MagicMock()
redis_mock.expire = MagicMock()
redis_mock.hgetall = MagicMock(return_value={})
redis_mock.hdel = MagicMock()
redis_mock.incr = MagicMock(return_value=1)

# 添加API目录到Python路径
import sys
sys.path.insert(0, PROJECT_DIR)

# 应用Redis Mock
from extensions import ext_redis
redis_patcher = patch.object(ext_redis, "redis_client", redis_mock)
redis_patcher.start()

@pytest.fixture
def app() -> Flask:
    """提供Flask应用实例"""
    return CACHED_APP

@pytest.fixture(autouse=True)
def _provide_app_context(app: Flask):
    """自动提供应用上下文"""
    with app.app_context():
        yield

@pytest.fixture(autouse=True)
def reset_redis_mock():
    """在每个测试前重置Redis Mock"""
    redis_mock.reset_mock()
    redis_mock.get.return_value = None
    redis_mock.setex.return_value = None
    redis_mock.setnx.return_value = None
    redis_mock.delete.return_value = None
    redis_mock.exists.return_value = False
    redis_mock.set.return_value = None
    redis_mock.expire.return_value = None
    redis_mock.hgetall.return_value = {}
    redis_mock.hdel.return_value = None
    redis_mock.incr.return_value = 1
```

**设计特点**:
- 提供Flask应用实例
- 自动应用上下文管理
- Redis客户端Mock
- 测试隔离和清理

### 2. `integration_tests/conftest.py` - 集成测试配置

**职责**: 提供集成测试的基础配置和数据库fixture。

**核心配置**:
```python
import pathlib
import random
import secrets
from collections.abc import Generator
import pytest
from flask import Flask
from flask.testing import FlaskClient
from sqlalchemy.orm import Session

from app_factory import create_app
from models import Account, DifySetup, Tenant, TenantAccountJoin, db
from services.account_service import AccountService, RegisterService

# 加载环境变量
def _load_env() -> None:
    current_file_path = pathlib.Path(__file__).absolute()
    files_to_load = [".env", "vdb.env"]
    
    env_file_paths = [current_file_path.parent / i for i in files_to_load]
    for path in env_file_paths:
        if not path.exists():
            continue
        
        from dotenv import load_dotenv
        load_dotenv(str(path), override=True)

_load_env()

_CACHED_APP = create_app()

@pytest.fixture
def flask_app() -> Flask:
    """提供Flask应用实例"""
    return _CACHED_APP

@pytest.fixture(scope="session")
def setup_account(request) -> Generator[Account, None, None]:
    """设置测试账户
    
    创建Account和Tenant，并插入DifySetup记录到数据库。
    大多数控制器测试可能需要Dify已经成功设置。
    """
    with _CACHED_APP.test_request_context():
        rand_suffix = random.randint(int(1e6), int(1e7))
        name = f"test-user-{rand_suffix}"
        email = f"{name}@example.com"
        RegisterService.setup(
            email=email,
            name=name,
            password=secrets.token_hex(16),
            ip_address="localhost",
        )

    with _CACHED_APP.test_request_context():
        with Session(bind=db.engine, expire_on_commit=False) as session:
            account = session.query(Account).filter_by(email=email).one()

    yield account

    # 清理测试数据
    with _CACHED_APP.test_request_context():
        db.session.query(DifySetup).delete()
        db.session.query(TenantAccountJoin).delete()
        db.session.query(Account).delete()
        db.session.query(Tenant).delete()
        db.session.commit()

@pytest.fixture
def flask_req_ctx():
    """提供Flask请求上下文"""
    with _CACHED_APP.test_request_context():
        yield

@pytest.fixture
def auth_header(setup_account) -> dict[str, str]:
    """提供认证头"""
    token = AccountService.get_account_jwt_token(setup_account)
    return {"Authorization": f"Bearer {token}"}

@pytest.fixture
def test_client() -> Generator[FlaskClient, None, None]:
    """提供测试客户端"""
    with _CACHED_APP.test_client() as client:
        yield client
```

**设计特点**:
- 环境变量加载
- 数据库测试账户创建
- 认证token生成
- 测试数据清理

## 测试类型详解

### 1. 单元测试

**职责**: 测试单个函数、类或模块的功能。

**测试示例**:
```python
# tests/unit_tests/services/test_account_service.py
import pytest
from unittest.mock import Mock, patch
from services.account_service import AccountService

class TestAccountService:
    """账户服务单元测试"""
    
    def test_create_account_success(self):
        """测试成功创建账户"""
        # 准备测试数据
        email = "test@example.com"
        password = "password123"
        name = "Test User"
        
        # Mock数据库会话
        with patch('services.account_service.db') as mock_db:
            mock_db.session.add.return_value = None
            mock_db.session.commit.return_value = None
            
            # 执行测试
            result = AccountService.create_account(email, password, name)
            
            # 验证结果
            assert result.email == email
            assert result.name == name
            mock_db.session.add.assert_called_once()
            mock_db.session.commit.assert_called_once()
    
    def test_create_account_duplicate_email(self):
        """测试重复邮箱创建账户"""
        email = "existing@example.com"
        password = "password123"
        name = "Test User"
        
        # Mock数据库查询返回已存在的账户
        with patch('services.account_service.db') as mock_db:
            mock_db.session.query.return_value.filter.return_value.first.return_value = Mock()
            
            # 验证抛出异常
            with pytest.raises(ValueError, match="Email already exists"):
                AccountService.create_account(email, password, name)
```

### 2. 集成测试

**职责**: 测试多个组件之间的交互。

**测试示例**:
```python
# tests/integration_tests/controllers/test_app_controller.py
import pytest
from flask import Flask

class TestAppController:
    """应用控制器集成测试"""
    
    def test_create_app_success(self, test_client, auth_header):
        """测试成功创建应用"""
        # 准备测试数据
        app_data = {
            "name": "Test App",
            "description": "Test Description",
            "mode": "chat"
        }
        
        # 发送请求
        response = test_client.post(
            "/console/api/apps",
            json=app_data,
            headers=auth_header
        )
        
        # 验证响应
        assert response.status_code == 201
        data = response.get_json()
        assert data["name"] == app_data["name"]
        assert data["mode"] == app_data["mode"]
    
    def test_create_app_unauthorized(self, test_client):
        """测试未授权创建应用"""
        app_data = {
            "name": "Test App",
            "description": "Test Description",
            "mode": "chat"
        }
        
        # 发送未授权请求
        response = test_client.post(
            "/console/api/apps",
            json=app_data
        )
        
        # 验证响应
        assert response.status_code == 401
```

### 3. 端到端测试

**职责**: 测试完整的业务流程。

**测试示例**:
```python
# tests/integration_tests/workflow/test_workflow_execution.py
import pytest
from models.workflow import Workflow, WorkflowRun

class TestWorkflowExecution:
    """工作流执行端到端测试"""
    
    def test_complete_workflow_execution(self, test_client, auth_header, setup_account):
        """测试完整工作流执行"""
        # 1. 创建工作流
        workflow_data = {
            "name": "Test Workflow",
            "description": "Test Workflow Description",
            "nodes": [
                {
                    "id": "node1",
                    "type": "llm",
                    "data": {"prompt": "Hello, world!"}
                }
            ],
            "edges": []
        }
        
        workflow_response = test_client.post(
            "/console/api/workflows",
            json=workflow_data,
            headers=auth_header
        )
        assert workflow_response.status_code == 201
        workflow_id = workflow_response.get_json()["id"]
        
        # 2. 执行工作流
        execution_data = {
            "inputs": {"user_input": "Test input"}
        }
        
        execution_response = test_client.post(
            f"/console/api/workflows/{workflow_id}/runs",
            json=execution_data,
            headers=auth_header
        )
        assert execution_response.status_code == 201
        run_id = execution_response.get_json()["id"]
        
        # 3. 检查执行状态
        status_response = test_client.get(
            f"/console/api/workflows/{workflow_id}/runs/{run_id}",
            headers=auth_header
        )
        assert status_response.status_code == 200
        
        # 4. 验证执行结果
        data = status_response.get_json()
        assert data["status"] in ["completed", "running"]
```

## 测试策略

### 1. 测试金字塔

**单元测试 (70%)**:
- 测试单个函数和类
- 快速执行
- 高覆盖率

**集成测试 (20%)**:
- 测试组件交互
- 数据库集成
- API集成

**端到端测试 (10%)**:
- 测试完整业务流程
- 用户场景验证
- 系统集成验证

### 2. 测试覆盖策略

**代码覆盖率**:
```python
# pytest.ini
[tool:pytest]
addopts = 
    --cov=.
    --cov-report=html
    --cov-report=term-missing
    --cov-fail-under=80
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

**关键路径测试**:
- 用户注册和登录
- 应用创建和管理
- 工作流执行
- 数据处理流程

### 3. Mock策略

**外部服务Mock**:
```python
@pytest.fixture
def mock_openai_client():
    """Mock OpenAI客户端"""
    with patch('core.model_runtime.providers.openai.openai_client.OpenAIClient') as mock:
        mock.return_value.chat_completion.return_value = {
            "choices": [{"message": {"content": "Mock response"}}]
        }
        yield mock

@pytest.fixture
def mock_redis_client():
    """Mock Redis客户端"""
    with patch('extensions.ext_redis.redis_client') as mock:
        mock.get.return_value = None
        mock.setex.return_value = None
        yield mock
```

## 测试最佳实践

### 1. 测试命名规范

**测试函数命名**:
```python
def test_function_name_scenario_expected_result():
    """测试函数名_场景_期望结果"""
    pass

# 示例
def test_create_account_valid_data_returns_account():
    """测试创建账户_有效数据_返回账户"""
    pass

def test_create_account_duplicate_email_raises_error():
    """测试创建账户_重复邮箱_抛出错误"""
    pass
```

**测试类命名**:
```python
class TestClassName:
    """测试类名"""
    pass

# 示例
class TestAccountService:
    """账户服务测试"""
    pass
```

### 2. 测试数据管理

**测试数据工厂**:
```python
# tests/factories.py
import factory
from models.account import Account
from models.app import App

class AccountFactory(factory.Factory):
    """账户工厂"""
    class Meta:
        model = Account
    
    email = factory.Sequence(lambda n: f"user{n}@example.com")
    name = factory.Faker('name')
    password = factory.Faker('password')

class AppFactory(factory.Factory):
    """应用工厂"""
    class Meta:
        model = App
    
    name = factory.Faker('company')
    description = factory.Faker('text')
    mode = "chat"
    tenant_id = factory.SubFactory(AccountFactory).tenant_id
```

**测试数据清理**:
```python
@pytest.fixture(autouse=True)
def cleanup_test_data():
    """自动清理测试数据"""
    yield
    # 清理测试数据
    db.session.query(TestModel).delete()
    db.session.commit()
```

### 3. 测试断言

**详细断言**:
```python
def test_user_creation():
    """测试用户创建"""
    user = create_user("test@example.com", "password")
    
    # 详细断言
    assert user.email == "test@example.com"
    assert user.name is not None
    assert user.created_at is not None
    assert user.status == "active"
    
    # 验证数据库记录
    db_user = db.session.query(User).filter_by(email="test@example.com").first()
    assert db_user is not None
    assert db_user.id == user.id
```

## 测试工具和配置

### 1. pytest配置

**pytest.ini**:
```ini
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --disable-warnings
markers =
    unit: Unit tests
    integration: Integration tests
    slow: Slow running tests
    api: API tests
```

**conftest.py**:
```python
import pytest

def pytest_configure(config):
    """pytest配置"""
    config.addinivalue_line(
        "markers", "unit: mark test as unit test"
    )
    config.addinivalue_line(
        "markers", "integration: mark test as integration test"
    )

def pytest_collection_modifyitems(config, items):
    """修改测试收集"""
    for item in items:
        if "unit_tests" in item.nodeid:
            item.add_marker(pytest.mark.unit)
        elif "integration_tests" in item.nodeid:
            item.add_marker(pytest.mark.integration)
```

### 2. 测试运行

**运行所有测试**:
```bash
pytest
```

**运行特定类型测试**:
```bash
# 运行单元测试
pytest -m unit

# 运行集成测试
pytest -m integration

# 运行特定模块测试
pytest tests/unit_tests/services/

# 运行特定测试文件
pytest tests/unit_tests/services/test_account_service.py
```

**生成覆盖率报告**:
```bash
pytest --cov=. --cov-report=html
```

## 持续集成

### 1. GitHub Actions配置

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Run tests
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379/0
      run: |
        pytest --cov=. --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
```

### 2. 测试质量门禁

**覆盖率要求**:
```python
# 在pytest配置中设置最低覆盖率
addopts = --cov-fail-under=80
```

**测试通过率要求**:
```yaml
# 在CI配置中要求所有测试通过
- name: Run tests
  run: pytest
  continue-on-error: false
```

## 故障排除

### 常见问题

1. **测试环境问题**
   - 检查环境变量配置
   - 验证数据库连接
   - 确认依赖服务可用

2. **Mock问题**
   - 检查Mock路径正确性
   - 验证Mock返回值
   - 确认Mock作用域

3. **测试数据问题**
   - 检查测试数据清理
   - 验证数据隔离
   - 确认事务回滚

### 调试技巧

```python
import logging

# 启用详细日志
logging.basicConfig(level=logging.DEBUG)

# 在测试中使用pdb调试
import pdb; pdb.set_trace()

# 使用pytest的--pdb选项
pytest --pdb test_file.py
```

---

*测试层为Dify提供了全面的质量保证机制，确保代码的正确性和可靠性，支持持续集成和部署流程。* 