# 13-工具库层

## 概述

工具库层（`libs/`）提供系统中使用的各种通用工具、辅助函数和第三方集成。该层包含日期时间处理、邮件国际化、加密工具、OAuth认证、文件操作等实用功能，为整个系统提供基础的工具支持。

## 目录结构

```
libs/
├── __init__.py                    # 工具库模块初始化
├── helper.py                      # 核心辅助函数
├── datetime_utils.py              # 日期时间工具
├── email_i18n.py                  # 邮件国际化
├── uuid_utils.py                  # UUID工具
├── password.py                    # 密码工具
├── rsa.py                         # RSA加密工具
├── gmpy2_pkcs10aep_cipher.py     # 高级加密工具
├── oauth.py                       # OAuth认证
├── oauth_data_source.py          # OAuth数据源
├── login.py                       # 登录工具
├── passport.py                    # 护照工具
├── smtp.py                        # SMTP邮件
├── sendgrid.py                    # SendGrid邮件
├── external_api.py                # 外部API工具
├── file_utils.py                  # 文件工具
├── flask_utils.py                 # Flask工具
├── json_in_md_parser.py           # JSON解析器
├── infinite_scroll_pagination.py  # 无限滚动分页
└── exception.py                   # 异常处理
```

## 核心工具详解

### 1. `helper.py` - 核心辅助函数

**职责**: 提供系统中最常用的辅助函数和工具类。

**核心功能**:

#### 1.1 用户工具函数
```python
def extract_tenant_id(user: Union["Account", "EndUser"]) -> str | None:
    """从用户对象中提取租户ID"""
    from models.account import Account
    from models.model import EndUser

    if isinstance(user, Account):
        return user.current_tenant_id
    elif isinstance(user, EndUser):
        return user.tenant_id
    else:
        raise ValueError(f"Invalid user type: {type(user)}. Expected Account or EndUser.")
```

#### 1.2 自定义字段类
```python
class AppIconUrlField(fields.Raw):
    """应用图标URL字段"""
    def output(self, key, obj):
        if obj is None:
            return None

        from models.model import App, IconType, Site

        if isinstance(obj, dict) and "app" in obj:
            obj = obj["app"]

        if isinstance(obj, App | Site) and obj.icon_type == IconType.IMAGE.value:
            return file_helpers.get_signed_file_url(obj.icon)
        return None

class AvatarUrlField(fields.Raw):
    """头像URL字段"""
    def output(self, key, obj):
        if obj is None:
            return None

        from models.account import Account

        if isinstance(obj, Account) and obj.avatar is not None:
            return file_helpers.get_signed_file_url(obj.avatar)
        return None

class TimestampField(fields.Raw):
    """时间戳字段"""
    def format(self, value) -> int:
        return int(value.timestamp())
```

#### 1.3 验证函数
```python
def email(email):
    """邮箱格式验证"""
    pattern = r"^[\w\.!#$%&'*+\-/=?^_`{|}~]+@([\w-]+\.)+[\w-]{2,}$"
    if re.match(pattern, email) is not None:
        return email
    raise ValueError(f"{email} is not a valid email.")

def uuid_value(value):
    """UUID格式验证"""
    try:
        uuid.UUID(value)
        return value
    except (ValueError, AttributeError):
        raise ValueError(f"{value} is not a valid UUID.")

def alphanumeric(value: str):
    """字母数字下划线验证"""
    if re.match(r"^[a-zA-Z0-9_]+$", value):
        return value
    raise ValueError(f"{value} must be alphanumeric and underlined.")
```

#### 1.4 令牌管理器
```python
class TokenManager:
    """令牌管理器"""
    @classmethod
    def generate_token(
        cls,
        token_type: str,
        account: Optional["Account"] = None,
        email: Optional[str] = None,
        additional_data: Optional[dict] = None,
    ) -> str:
        """生成令牌"""
        token = secrets.token_urlsafe(32)
        token_data = {
            "token": token,
            "account_id": account.id if account else None,
            "email": email,
            "additional_data": additional_data or {},
            "created_at": time.time(),
        }
        
        # 存储到Redis
        redis_client.setex(
            cls._get_token_key(token, token_type),
            3600,  # 1小时过期
            json.dumps(token_data)
        )
        
        return token

    @classmethod
    def get_token_data(cls, token: str, token_type: str) -> Optional[dict[str, Any]]:
        """获取令牌数据"""
        token_key = cls._get_token_key(token, token_type)
        token_data = redis_client.get(token_key)
        if token_data:
            return json.loads(token_data)
        return None
```

#### 1.5 速率限制器
```python
class RateLimiter:
    """速率限制器"""
    def __init__(self, prefix: str, max_attempts: int, time_window: int):
        self.prefix = prefix
        self.max_attempts = max_attempts
        self.time_window = time_window

    def is_rate_limited(self, email: str) -> bool:
        """检查是否被限制"""
        key = self._get_key(email)
        attempts = redis_client.get(key)
        return attempts and int(attempts) >= self.max_attempts

    def increment_rate_limit(self, email: str):
        """增加限制计数"""
        key = self._get_key(email)
        pipe = redis_client.pipeline()
        pipe.incr(key)
        pipe.expire(key, self.time_window)
        pipe.execute()
```

### 2. `datetime_utils.py` - 日期时间工具

**职责**: 提供日期时间处理的工具函数。

**核心功能**:
```python
class _NowFunction(Protocol):
    @abc.abstractmethod
    def __call__(self, tz: datetime.timezone | None) -> datetime.datetime:
        pass

# 抽象时间获取函数，便于测试时模拟
_now_func: _NowFunction = datetime.datetime.now

def naive_utc_now() -> datetime.datetime:
    """返回当前UTC时间的朴素datetime对象（无时区信息）"""
    return _now_func(datetime.UTC).replace(tzinfo=None)
```

**设计特点**:
- 抽象时间获取，便于测试
- 支持时区处理
- 提供UTC时间工具

### 3. `email_i18n.py` - 邮件国际化

**职责**: 提供邮件国际化和模板渲染功能。

**核心组件**:

#### 3.1 邮件类型枚举
```python
class EmailType(Enum):
    """支持的邮件类型"""
    RESET_PASSWORD = "reset_password"
    INVITE_MEMBER = "invite_member"
    EMAIL_CODE_LOGIN = "email_code_login"
    CHANGE_EMAIL_OLD = "change_email_old"
    CHANGE_EMAIL_NEW = "change_email_new"
    OWNER_TRANSFER_CONFIRM = "owner_transfer_confirm"
    OWNER_TRANSFER_OLD_NOTIFY = "owner_transfer_old_notify"
    OWNER_TRANSFER_NEW_NOTIFY = "owner_transfer_new_notify"
    ACCOUNT_DELETION_SUCCESS = "account_deletion_success"
    ACCOUNT_DELETION_VERIFICATION = "account_deletion_verification"
    ENTERPRISE_CUSTOM = "enterprise_custom"
    QUEUE_MONITOR_ALERT = "queue_monitor_alert"
    DOCUMENT_CLEAN_NOTIFY = "document_clean_notify"
```

#### 3.2 邮件语言支持
```python
class EmailLanguage(Enum):
    """支持的邮件语言"""
    EN_US = "en-US"
    ZH_HANS = "zh-Hans"

    @classmethod
    def from_language_code(cls, language_code: str) -> "EmailLanguage":
        """从语言代码转换为邮件语言，默认回退到英语"""
        if language_code == "zh-Hans":
            return cls.ZH_HANS
        return cls.EN_US
```

#### 3.3 邮件模板配置
```python
@dataclass(frozen=True)
class EmailTemplate:
    """邮件模板配置"""
    subject: str
    template_path: str
    branded_template_path: str

class EmailI18nConfig(BaseModel):
    """邮件国际化配置"""
    model_config = {"frozen": True, "extra": "forbid"}

    templates: dict[EmailType, dict[EmailLanguage, EmailTemplate]] = Field(
        default_factory=dict, 
        description="邮件类型到语言特定模板的映射"
    )

    def get_template(self, email_type: EmailType, language: EmailLanguage) -> EmailTemplate:
        """获取特定邮件类型和语言的模板配置"""
        type_templates = self.templates.get(email_type)
        if not type_templates:
            raise ValueError(f"No templates configured for email type: {email_type}")

        template = type_templates.get(language)
        if not template:
            # 回退到英语
            template = type_templates.get(EmailLanguage.EN_US)
            if not template:
                raise ValueError(f"No template found for {email_type} in {language} or English")

        return template
```

#### 3.4 邮件服务
```python
class EmailI18nService:
    """邮件国际化服务"""
    def __init__(
        self,
        config: EmailI18nConfig,
        renderer: EmailRenderer,
        branding_service: BrandingService,
        sender: EmailSender,
    ) -> None:
        self.config = config
        self.renderer = renderer
        self.branding_service = branding_service
        self.sender = sender

    def send_email(
        self,
        email_type: EmailType,
        language_code: str,
        to: str,
        template_context: Optional[dict[str, Any]] = None,
    ) -> None:
        """发送邮件"""
        language = EmailLanguage.from_language_code(language_code)
        template_context = template_context or {}
        
        # 渲染邮件内容
        content = self._render_email_content(email_type, language, template_context)
        
        # 发送邮件
        self.sender.send_email(to, content.subject, content.html_content)
```

### 4. `oauth.py` - OAuth认证

**职责**: 提供OAuth认证相关的工具函数。

**核心功能**:
```python
def get_oauth_client(provider: str) -> OAuthClient:
    """获取OAuth客户端"""
    # 根据提供商获取相应的OAuth客户端
    pass

def generate_oauth_state() -> str:
    """生成OAuth状态参数"""
    return secrets.token_urlsafe(32)

def validate_oauth_state(state: str, stored_state: str) -> bool:
    """验证OAuth状态参数"""
    return state == stored_state
```

### 5. `rsa.py` - RSA加密工具

**职责**: 提供RSA加密和解密功能。

**核心功能**:
```python
def generate_rsa_key_pair() -> tuple[str, str]:
    """生成RSA密钥对"""
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric import rsa

    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
    )
    
    public_key = private_key.public_key()
    
    # 序列化密钥
    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    
    return private_pem.decode(), public_pem.decode()

def encrypt_with_rsa(data: str, public_key: str) -> str:
    """使用RSA公钥加密数据"""
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    
    public_key_obj = serialization.load_pem_public_key(public_key.encode())
    encrypted = public_key_obj.encrypt(
        data.encode(),
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return base64.b64encode(encrypted).decode()
```

### 6. `password.py` - 密码工具

**职责**: 提供密码哈希和验证功能。

**核心功能**:
```python
def hash_password(password: str) -> str:
    """哈希密码"""
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    """验证密码"""
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

def generate_secure_password(length: int = 12) -> str:
    """生成安全密码"""
    characters = string.ascii_letters + string.digits + string.punctuation
    return ''.join(secrets.choice(characters) for _ in range(length))
```

### 7. `file_utils.py` - 文件工具

**职责**: 提供文件操作相关的工具函数。

**核心功能**:
```python
def get_file_extension(filename: str) -> str:
    """获取文件扩展名"""
    return os.path.splitext(filename)[1].lower()

def is_safe_filename(filename: str) -> bool:
    """检查文件名是否安全"""
    # 检查文件名是否包含危险字符
    dangerous_chars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|']
    return not any(char in filename for char in dangerous_chars)

def get_file_size_mb(file_path: str) -> float:
    """获取文件大小（MB）"""
    return os.path.getsize(file_path) / (1024 * 1024)
```

## 工具库设计原则

### 1. 功能分类

**核心工具**:
- 日期时间处理
- 字符串处理
- 数据验证

**安全工具**:
- 加密解密
- 密码处理
- 令牌管理

**集成工具**:
- OAuth认证
- 邮件发送
- 外部API

**辅助工具**:
- 文件操作
- 分页处理
- 异常处理

### 2. 设计特点

**单一职责**:
- 每个工具函数只负责一个特定功能
- 避免功能耦合

**可测试性**:
- 提供抽象接口便于测试
- 支持依赖注入

**国际化支持**:
- 多语言邮件模板
- 时区处理
- 本地化配置

**安全性**:
- 安全的密码哈希
- 令牌管理
- 输入验证

## 使用示例

### 1. 日期时间处理

```python
from libs.datetime_utils import naive_utc_now

def get_current_time():
    """获取当前UTC时间"""
    return naive_utc_now()

def format_timestamp(timestamp):
    """格式化时间戳"""
    return timestamp.strftime("%Y-%m-%d %H:%M:%S")
```

### 2. 邮件发送

```python
from libs.email_i18n import get_email_i18n_service, EmailType

def send_reset_password_email(email: str, language_code: str, reset_code: str):
    """发送重置密码邮件"""
    email_service = get_email_i18n_service()
    email_service.send_email(
        email_type=EmailType.RESET_PASSWORD,
        language_code=language_code,
        to=email,
        template_context={"reset_code": reset_code}
    )
```

### 3. 令牌管理

```python
from libs.helper import TokenManager

def create_reset_token(account):
    """创建重置令牌"""
    return TokenManager.generate_token(
        token_type="password_reset",
        account=account,
        email=account.email
    )

def verify_reset_token(token):
    """验证重置令牌"""
    token_data = TokenManager.get_token_data(token, "password_reset")
    if token_data:
        return token_data.get("account_id")
    return None
```

### 4. 速率限制

```python
from libs.helper import RateLimiter

# 创建登录速率限制器
login_limiter = RateLimiter("login", max_attempts=5, time_window=300)

def check_login_rate_limit(email: str) -> bool:
    """检查登录速率限制"""
    if login_limiter.is_rate_limited(email):
        return False
    
    login_limiter.increment_rate_limit(email)
    return True
```

### 5. 数据验证

```python
from libs.helper import email, uuid_value, alphanumeric

def validate_user_data(user_data: dict):
    """验证用户数据"""
    try:
        # 验证邮箱
        email(user_data["email"])
        
        # 验证UUID
        uuid_value(user_data["id"])
        
        # 验证用户名
        alphanumeric(user_data["username"])
        
        return True
    except ValueError as e:
        print(f"验证失败: {e}")
        return False
```

## 最佳实践

### 1. 工具函数设计

**命名规范**:
- 使用清晰的函数名
- 遵循Python命名约定
- 提供类型注解

**错误处理**:
- 提供详细的错误信息
- 使用适当的异常类型
- 支持优雅的错误恢复

**文档注释**:
- 提供函数说明
- 描述参数和返回值
- 包含使用示例

### 2. 性能优化

**缓存机制**:
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def expensive_calculation(data):
    """缓存昂贵计算的结果"""
    # 计算逻辑
    return result
```

**批量处理**:
```python
def process_batch(items: list, batch_size: int = 100):
    """批量处理数据"""
    for i in range(0, len(items), batch_size):
        batch = items[i:i + batch_size]
        # 处理批次
        yield process_batch_items(batch)
```

### 3. 测试支持

```python
# 模拟时间函数
def mock_now(tz=None):
    return datetime.datetime(2023, 1, 1, 12, 0, 0, tzinfo=tz)

# 在测试中使用
import libs.datetime_utils as dt_utils
dt_utils._now_func = mock_now
```

## 扩展指南

### 添加新工具函数

1. **创建工具文件**:
```python
# libs/new_utils.py
from typing import Any

def new_utility_function(param: Any) -> Any:
    """新工具函数"""
    # 实现逻辑
    return result
```

2. **添加测试**:
```python
def test_new_utility_function():
    """测试新工具函数"""
    result = new_utility_function(test_input)
    assert result == expected_output
```

3. **更新文档**:
```python
# 在相应的文档中添加说明
"""
新工具函数说明
参数: param - 参数说明
返回: 返回值说明
"""
```

### 自定义工具类

```python
class CustomToolClass:
    def __init__(self, config: dict):
        self.config = config
    
    def process_data(self, data: Any) -> Any:
        """处理数据"""
        # 处理逻辑
        return processed_data
    
    def validate_config(self) -> bool:
        """验证配置"""
        # 验证逻辑
        return is_valid
```

## 故障排除

### 常见问题

1. **时区问题**
   - 使用UTC时间作为标准
   - 正确处理时区转换
   - 避免时区混淆

2. **编码问题**
   - 统一使用UTF-8编码
   - 正确处理特殊字符
   - 避免编码错误

3. **性能问题**
   - 使用缓存机制
   - 避免重复计算
   - 优化算法复杂度

### 调试技巧

```python
import logging

logger = logging.getLogger(__name__)

def debug_utility_function(func_name: str):
    """调试工具函数"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            logger.debug(f"调用工具函数: {func_name}, 参数: {args}, {kwargs}")
            try:
                result = func(*args, **kwargs)
                logger.debug(f"工具函数 {func_name} 执行成功: {result}")
                return result
            except Exception as e:
                logger.error(f"工具函数 {func_name} 执行失败: {e}")
                raise
        return wrapper
    return decorator
```

---

*工具库层为Dify提供了丰富、可靠的工具函数，支持系统的各种功能需求，确保代码的可维护性和可扩展性。* 