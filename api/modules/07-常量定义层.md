# 07-常量定义层

## 概述

常量定义层（`constants/`）负责定义系统中使用的各种常量、枚举值、配置项和国际化支持。这些常量在整个应用中被广泛使用，确保代码的一致性和可维护性。

## 目录结构

```
constants/
├── __init__.py                    # 常量模块初始化
├── languages.py                   # 语言和时区映射
├── mimetypes.py                   # MIME类型定义
├── model_template.py              # 应用模板配置
├── tts_auto_play_timeout.py      # TTS自动播放超时
└── recommended_apps.json          # 推荐应用配置
```

## 核心文件详解

### 1. `__init__.py` - 常量模块初始化

**职责**: 定义系统核心常量，包括文件扩展名、隐藏值、默认配置等。

**核心常量**:
```python
# 系统特殊值
HIDDEN_VALUE = "[__HIDDEN__]"           # 隐藏值标识
UNKNOWN_VALUE = "[__UNKNOWN__]"         # 未知值标识
UUID_NIL = "00000000-0000-0000-0000-000000000000"  # 空UUID

# 文件限制
DEFAULT_FILE_NUMBER_LIMITS = 3          # 默认文件数量限制

# 文件扩展名支持
IMAGE_EXTENSIONS = ["jpg", "jpeg", "png", "webp", "gif", "svg"]
VIDEO_EXTENSIONS = ["mp4", "mov", "mpeg", "mpga"]
AUDIO_EXTENSIONS = ["mp3", "m4a", "wav", "webm", "amr"]
DOCUMENT_EXTENSIONS = [...]              # 根据ETL类型动态配置
```

**设计特点**:
- 支持大小写扩展名
- 根据ETL类型动态配置文档扩展名
- 统一的特殊值标识

### 2. `languages.py` - 语言和时区支持

**职责**: 定义支持的语言列表和对应的时区映射。

**核心功能**:
```python
# 语言时区映射
language_timezone_mapping = {
    "en-US": "America/New_York",
    "zh-Hans": "Asia/Shanghai",
    "zh-Hant": "Asia/Taipei",
    "pt-BR": "America/Sao_Paulo",
    # ... 更多语言支持
}

# 支持的语言列表
languages = list(language_timezone_mapping.keys())

# 语言验证函数
def supported_language(lang):
    if lang in languages:
        return lang
    raise ValueError(f"{lang} is not a valid language.")
```

**支持的语言**:
- **英语**: en-US (美国东部时间)
- **中文**: zh-Hans (上海), zh-Hant (台北)
- **其他语言**: 葡萄牙语、西班牙语、法语、德语、日语、韩语等

### 3. `mimetypes.py` - MIME类型定义

**职责**: 定义默认的MIME类型和文件扩展名。

**核心常量**:
```python
# 默认内容类型
DEFAULT_MIME_TYPE = "application/octet-stream"

# 默认文件扩展名
DEFAULT_EXTENSION = ".bin"
```

**设计原则**:
- 保持MIME类型和扩展名的一致性
- 为未知文件类型提供默认处理

### 4. `model_template.py` - 应用模板配置

**职责**: 定义不同应用模式的默认模板配置。

**支持的应用模式**:
```python
default_app_templates = {
    AppMode.WORKFLOW: {...},        # 工作流模式
    AppMode.COMPLETION: {...},      # 补全模式
    AppMode.CHAT: {...},            # 聊天模式
    AppMode.ADVANCED_CHAT: {...},   # 高级聊天模式
    AppMode.AGENT_CHAT: {...},      # 智能体聊天模式
}
```

**模板结构**:
```python
{
    "app": {
        "mode": "chat",
        "enable_site": True,
        "enable_api": True,
    },
    "model_config": {
        "model": {
            "provider": "openai",
            "name": "gpt-4o",
            "mode": "chat",
            "completion_params": {},
        },
        "user_input_form": [...],  # 用户输入表单
        "pre_prompt": "{{query}}", # 预提示词
    },
}
```

### 5. `tts_auto_play_timeout.py` - TTS超时配置

**职责**: 定义文本转语音自动播放的超时时间。

### 6. `recommended_apps.json` - 推荐应用配置

**职责**: 存储推荐应用的配置信息，用于应用市场展示。

## 设计原则

### 1. 集中管理
- 所有常量统一在constants模块中定义
- 避免在代码中硬编码魔法数字和字符串

### 2. 类型安全
- 使用枚举类型定义有限的选择项
- 提供验证函数确保值的有效性

### 3. 国际化支持
- 支持多语言和时区
- 提供语言验证机制

### 4. 配置驱动
- 根据系统配置动态调整常量值
- 支持不同环境的不同配置

### 5. 扩展性
- 易于添加新的语言支持
- 支持新的文件类型扩展

## 使用示例

### 语言验证
```python
from constants import supported_language

try:
    lang = supported_language("zh-Hans")
    print(f"支持的语言: {lang}")
except ValueError as e:
    print(f"不支持的语言: {e}")
```

### 文件类型检查
```python
from constants import IMAGE_EXTENSIONS, DOCUMENT_EXTENSIONS

def is_image_file(filename):
    ext = filename.split('.')[-1].lower()
    return ext in IMAGE_EXTENSIONS

def is_document_file(filename):
    ext = filename.split('.')[-1].lower()
    return ext in DOCUMENT_EXTENSIONS
```

### 应用模板使用
```python
from constants.model_template import default_app_templates
from models.model import AppMode

# 获取聊天模式的默认模板
chat_template = default_app_templates[AppMode.CHAT]
```

## 最佳实践

### 1. 常量命名
- 使用大写字母和下划线
- 名称要具有描述性
- 避免缩写和模糊命名

### 2. 文档注释
- 为每个常量添加注释说明
- 说明常量的用途和使用场景

### 3. 类型注解
- 为复杂常量添加类型注解
- 提高代码的可读性和IDE支持

### 4. 测试覆盖
- 为常量验证函数编写测试
- 确保边界情况的处理

### 5. 版本兼容
- 在修改常量时考虑向后兼容性
- 提供迁移指南

## 扩展指南

### 添加新语言支持
1. 在`language_timezone_mapping`中添加新语言
2. 更新`languages`列表
3. 添加相应的测试用例

### 添加新文件类型
1. 在`__init__.py`中添加新的扩展名列表
2. 更新相关的MIME类型映射
3. 修改文件处理逻辑

### 添加新应用模板
1. 在`model_template.py`中定义新模板
2. 确保模板结构符合应用要求
3. 更新相关的创建逻辑

---

*常量定义层为整个系统提供了统一的配置和标准，确保代码的一致性和可维护性。* 